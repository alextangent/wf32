\ --------------------------- Change Block -------------------------------
\
\
\ ------------------------- End Change Block -----------------------------
\
\ Experimental: a fully optimising, STC based, ANS Forth compliant kernel
\
\
\    Copyright [c] 2005, 2017 by Alex McDonald (alex at rivadpm dot com)
\
\    Redistribution and use in source and binary forms, with or without
\    modification, are permitted provided that the following conditions are
\    met:
\
\    1. Redistributions of source code must retain the above copyright
\    notice, this list of conditions and the following disclaimer.
\
\    2. Redistributions in binary form must reproduce the above copyright
\    notice, this list of conditions and the following disclaimer in the
\    documentation and/or other materials provided with the distribution.
\
\    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
\    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
\    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
\    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
\    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
\    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
\    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
\    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
\    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (
\    INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
\    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ))
\
\
\
\ ------------------------------------------------------------------------
\
\    This is a complete rewrite of the original Win32Forth assembler.
\    All of the original code has been replaced, and in the belief that
\    there is no code from the original version, this code is being issued
\    under the BSD 2-Clause license.
\
\ ------------------------------------------------------------------------
\
\ Label references are of the form @@n, and labels are @@n:
\ 
\ Due to the way that code is generated, the reference to a forward label
\ needs to be generated after the label is resolved. For instance
\ 
\        mov { @@1 } 10   ...some code... @@1: ...
\ 
\ The code generated by the MOV is
\ 
\        C7 05 xx xx xx xx 0A 00 00 00 .. ..
\        
\ where xx xx xx xx represents the eventual address of @@1:. We pass a
\ dummy address on the invocation of @@1, and mark the entry for @@1:
\ to do a later resolve by memoizing.
\ 
\        C7 05 xx xx xx xx 0A 00 00 00 .. ..
\              ^ptr ----- +8 ----------^        ptr & offset
\              < -- 4 --->                      length of address
\ 
\ 1. the address of the displacement (RIP relative addresses are
\    calculated from this address + the offset to the end of the instruction)
\ 2. An offset to the area to modify (held as a small positive integer)
\ 3. The length of the address to modify (8, 4 or 1 byte)
\ 4. A relocation flag if xx is to be modified to an RIP offset (for
\    lengths of 1 and 4 only).
\ 
\ This information is requested by the @@n word via a callback fwd-
\ entry that is executed after the instruction is built.
\
\ Only 1 label per instruction can be requested, so this will generate
\ the wrong code;
\ 
\       mov { @@1 } @@2 ...
\
\ @@n: labels
\ -----------
\ 
\ Each label of the form @@n: defines the nth entry in an index table. 
\ 
\ def-label table
\ 
\   def.link:    0 -- no link entries
\             addr -- link entry; a list of forward references from @@n entries
\                     to be resolved
\ 
\   def.addr:    0 -- def.link = 0  -- not used
\                     def.link <> 0 -- used but unresolved
\             addr -- the address of the label. When referenced by @@n,
\                     returns this value; it's a backward reference.
\ 
\ At the end of processing, if any of def.addr are zero but def.link
\ are non-zero, then the reference has not been resolved and it's an error.
\ 
\ @@n forward references
\ ----------------------
\ 
\ Each reference to @@n looks up ref-label for index n+1.
\ 
\    def.addr:  addr -- return the already resolved address
\                  0 -- add a fwd- link to this address thru def.link.
\                       Return a dummy address.
\ 
\ fwd-label table
\ 
\    fwd.link:  next link or 0
\    fwd.ptr:   ptr to area to modify
\    fwd.bias:   offset to end of instruction
\    fwd.size:  size of the ptr
\    fwd.reloc: non-zero if the entry is to be RIP relocated
\
\ ------------------------------------------------------------------------

base @ decimal

in-hidden

( words to support forward referenced local labels )

begin-structure def%
  cell+              \  field: def.link
  field: def.addr
end-structure

begin-structure fwd%
  cell+              \  field:  fwd.link
  field:  fwd.ptr
  cfield: fwd.bias
  cfield: fwd.size
  cfield: fwd.reloc
  1+                 \ spare
end-structure

10  constant def-max     ( maximum number of labels: )
def% def-max * constant def-size ( size of an entry )
20 constant fwd-max      ( maximum number of fwd references )

create def-table         ( the reference table )
    def-size 3 * allot   ( base plus 3 macro levels )
create fwd-base          ( start of fwd reference links area )
    fwd-max fwd% * allot ( forward refs )

variable fwd-this        ( current fwd entry )
variable m-level         ( macro level )  

: @@-init ( initialize the tables and variables )
    ( -- )
    def-table def-size erase
    [ fwd-base fwd% - ] literal fwd-this !
    m-level off ;

@@-init

: ?unres ( -- ) ( check all referenced )
    def-table m-level @ + def-size bounds ?do
      i 2@ if 0= _?unresf else drop then
    def% +loop ;

: addref ( -- ) ( add fwd reference )
    fwd-this @
    asm-disp over fwd.ptr !  ( pointer to displacement )
    asm-here asm-disp - over fwd.bias c! ( possible offset )
    size-disp @ over fwd.size c! ( size )
    reloc? 0<> swap fwd.reloc c! ( and reloc flag )
    ['] noop is fwd-mark ;

: refer: ( n -- ) ( create words to reference local labels, @@n )
    create data-d,
    does> ( addr -- lab-addr ) ( return binding or pseudo address )
      @ m-level @ + dup def.addr @ ?dup if      
        nip                      ( resolved address )
      else                       ( label undefined, so generate fwd entry )
        fwd-this fwd% over +! @
        dup fwd% erase
        swap add-link        ( add in link )
        ['] addref is fwd-mark    ( word to create fwd ref )
        asm-here                 ( return dummy entry )
      then ;

: resolve ( fwd.link -- ) ( resolve fwd entries )
    dup fwd.ptr @               ( ptr to displacment )
    over fwd.reloc sb@ if       ( relocate? )
      over fwd.bias sb@ over +  ( end of instruction )
    else 0 then                 ( no relocation )
    asm-here swap - swap        ( RIP it )
    rot fwd.size sb@ 8bit = if
      over 1byte? 0= _?invrsz   ( branch offset too large )      
      asm-c!
    else
      asm-d!
    then ;

: label: ( n -- ) ( label, @@n: )
    create data-d,
    does> ( -- ) ( fixup addresses if needed )
      >r a; r>   ( end assembly )
      @ m-level @ + asm-here over def.addr !    ( set address cell )
      dup @ ['] resolve list-apply   ( iterate over nodes & call resolve )
      off ;                       ( zero def.link )

: _end-code ( -- ) ( end a code definition )
    previous a; ?unres ?csp reveal ;

: init-asm ( -- ) ( initalize assembly )
    also assembler /reset @@-init ;

: enter-macro ( -- ) ( set up macro relative local labels )
     m-level def-size over +! @
     def-table + def-size erase ;

: leave-macro ( -- ) ( go back to the old regime )
     ?unres [ def-size negate ] literal m-level +! ;

: (]macro) leave-macro a; ;

in-asm

0 def% * def-table + dup refer: @@0 label: @@0:
1 def% * def-table + dup refer: @@1 label: @@1:
2 def% * def-table + dup refer: @@2 label: @@2:
3 def% * def-table + dup refer: @@3 label: @@3:
4 def% * def-table + dup refer: @@4 label: @@4:
5 def% * def-table + dup refer: @@5 label: @@5:
6 def% * def-table + dup refer: @@6 label: @@6:
7 def% * def-table + dup refer: @@7 label: @@7:
8 def% * def-table + dup refer: @@8 label: @@8:
9 def% * def-table + dup refer: @@9 label: @@9:

: forth[ also forth ; immediate

: ;m ( end a macro definition )
    postpone leave-macro postpone ; previous ; immediate

: ]macro ( end generating code )
    postpone (]macro) previous ; immediate

: ]asm previous ; immediate
: a;]  postpone a; previous ; immediate
' ]asm alias ]forth immediate

defer end-code ' _end-code is end-code

in-forth

: ;code ( create the ;code part of a low level defining word )
  only-compiles> ( c: colon-sys -- ) \ compile
    0 to tail-call
    postpone ;
    -1 code-allot  \ remove the ret
    postpone (;code) postpone unnest
    init-asm postpone [  ;

: code  ( start a native code definition )
    ste-reset
    header hide            \ sets latestxt
    tpri tfa!              \ type is a primitive
    csp!
    init-asm postpone [ ;  \ runs in interpreted mode, not compile

: asm[ also assembler ; immediate

: macro[ ( generate code in a definition )
    also assembler postpone enter-macro ; immediate

: macro: ( create a macro in the assembler vocabulary )
    get-current >r also assembler definitions
    : postpone enter-macro r> set-current ;

base !
